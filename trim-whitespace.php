<?php

/**
 * Trim whitespace in multiline text
 *
 * By default, removes leading and trailing whitespace, collapses all other
 * space sequences, and removes blank lines. Most of this can be controlled
 * by passing an options array with the following keys:
 *
 *   - leading (bool, true): should we trim leading whitespace?
 *   - inside (bool, true): should we collapse spaces within a line
 *     (not leading whitespace)?
 *   - blankLines (int, 0): max number of consecutive blank lines;
 *     use false to disable.
 *   - tabWidth (int, 4): number of spaces to use when replacing tabs.
 *
 * The default settings can be used as basic minification for HTML text
 * (except for preformatted text!). This function can  be used remove extra
 * whitespace generated by a mix of PHP and HTML or by a template engine.
 *
 * This function forces two behaviors:
 *   - Trailing whitespace will be removed, always.
 *   - Tab characters will be replaced by space characters, always
 *     (for performance reasons).
 *
 * This was summarily tested on PHP 5.6 and PHP 7 to be as fast as possible,
 * and tested against different approches (e.g. splitting as an array and using
 * PHPâ€™s trim function). The fastest solution found was using str_replace when
 * possible and preg_replace otherwise with very simple regexps to avoid big
 * perf costs. The current implementation should be, if not the fastest
 * possible, probably close enough.
 *
 * @param string   $string
 * @param array    $options
 * @return string
 */
function trimWhitespace($string, $options=[]) {
    if (!is_string($string)) return '';
    $o = array_merge([
        'leading' => true,
        'inside' => true,
        'blankLines' => 0,
        'tabWidth' => 4
    ], $options);

    // Looking for spaces *and* tab characters is way too costly
    // (running times go x4 or x10) so we forcefully replace tab characters
    // with spaces, but make it configurable.
    $tabw = $o['tabWidth'];
    if (!is_int($tabw) || $tabw < 1 || $tabw > 8) {
        $tabw = 4;
    }

    // Replacement patterns should be applied in a specific order
    $patterns = [];

    // Trim leading whitespace first (if active). In typical scenarios,
    // especially for indented HTML, this will remove of the target whitespace
    // and it turns out to be really quick.
    if ($o['leading']) {
        $patterns[] = ['/^ {2,}/m', ''];
    }

    // Always trim at the end. Warning: this seems to be the costlier
    // operation, perhaps because looking ahead is harder?
    $patterns[] = ['/ +$/m', ''];

    // Collapse space sequences inside lines (excluding leading/trailing)
    if ($o['inside']) {
        // No leading spaces? We can avoid a very costly condition!
        // Using a look-behind (or similar solutions) seems to make the whole
        // function go 2x-4x slower (PHP7) or up to 10x slower (PHP 5.6),
        // except on very big strings where whatever perf penalty was incurred
        // seems to be more limited (or at least not exponential).
        $spaces = ($o['leading'] ? ' ' : '(?<=\b) ') . '{2,}';
        $patterns[] = [ '/' . $spaces . '/', ' ' ];
    }

    // Remove empty lines
    if (is_int($l = $o['blankLines']) && $l >= 0) {
        // We need blank lines to be truly empty; if trimStart is disabled
        // we have to fall back to this slightly more costly regex.
        if (!$o['leading']) $patterns[] = [ '/^ +$/m', '' ];
        // Not using '\R' because it's too slow, so we must do it by hand
        // and replace CRLF before touching any LF.
        $patterns[] = [ '/(\r\n){'.($l+2).',}/m', str_repeat("\r\n", $l+1) ];
        $patterns[] = [ '/\n{'.($l+2).',}/m', str_repeat("\n", $l+1) ];
    }

    // Doing the replacement in one go without storing intermediary
    // values helps a bit for big strings (around 20 percent quicker).
    return preg_replace(
        array_map(function($x){return $x[0];}, $patterns),
        array_map(function($x){return $x[1];}, $patterns),
        str_replace("\t", str_repeat(' ', $tabw), $string)
    );
}
